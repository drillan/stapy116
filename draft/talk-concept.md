# トークコンセプト

## 講演概要

「〜〜を作って」といったシンプルなプロンプトで実用的なコード生成に限界を感じていませんか？
本講演では、Claude Codeを効果的に活用するための実践的なアプローチを、Pythonの具体例とともにご紹介します。
効果的な記録の残し方、堅牢なコード作成、そして計画へのこだわりを通じて、開発プロセスの生産性を向上させる手法を紹介します。

## テーマ

Claude Codeで開発をするに当たって、次の3つの点を重視することを推奨する

- 計画・設計を立てる
- 記録を残す
- 堅牢なコードを書く

## 題材

- Pythonのコード
- サンプルのプロジェクトを要検討、例: Slackのクライアントを作る

## 背景

### Vibe CodingからAgentic Codingへの移行

従来の「〜を作って」といったシンプルなプロンプトによる開発アプローチ（Vibe Coding）から、より自律的で体系的なAgentic Codingへの移行が求められています。

#### Vibe Codingの特徴
- **直感的な対話型開発**：自然言語での指示に基づく即座のコード生成
- **クリエイティブな流れ重視**：開発者がフローに集中し、AIの提案を積極的に受け入れる
- **プロトタイプ向け**：迅速な試作と実験に最適化されたアプローチ
- **限界**：コードの品質管理や大規模開発には不向き

#### Agentic Codingの特徴
- **自律的な目標達成**：高レベルな指示から計画・実行・テストまでを自動化
- **体系的なアプローチ**：計画立案、実装、検証のサイクルを内包
- **企業レベル対応**：大規模コードベースやプロダクション環境に適用可能
- **開発者の役割変化**：実装者から監督者・設計者へ

#### なぜこの移行が重要か

1. **従来アプローチの限界**
   - 単発的な指示では複雑な要求に対応困難
   - コードの一貫性や品質の担保が困難
   - 大規模プロジェクトでの管理性の欠如

2. **生産性と品質の両立**
   - 自動化による開発速度向上
   - 体系的なテストと検証プロセス
   - 堅牢なコード実装の実現

3. **Claude Codeの位置づけ**
   - **ターミナルベースの自律エージェント**：IDEに依存しない柔軟な開発環境
   - **自律的なコードベース管理**：プロジェクト規模や言語を問わず対応
   - **実績のある自律性**：7時間の連続自律開発を実現
   - **Git統合**：プルリクエストやバージョン管理を自動化

#### 実践的な意味合いと業界トレンド

- **2026年までの予測**：多くの開発チームが「人間による指示 → エージェントによる実行 → 人間による審査」のパイプラインを採用
- **ハイブリッドアプローチ**：Vibe Codingの創造性とAgentic Codingの自動化を組み合わせた開発手法
- **開発パラダイムの転換**：AIを単なるツールから、自律的な開発パートナーへと位置づけ

AIが自律的にコードを書くためには綿密な計画と堅牢・頑健なコードを実装する必要があり、これが本講演で重視する3つのポイントの背景となっています。

### 計画・設計を立てる

Claude Codeにおける計画・設計は、単なる事前準備ではなく、自律的な開発を成功させるための核心的要素である。

#### なぜ計画・設計が重要なのか

1. **自律的な実行の前提条件**
   - AIが長時間にわたって一貫した判断を下すには明確な設計指針が必要
   - Anthropicの実績では7時間の連続自律開発を実現
   - 複雑なタスクを小さな検証可能な単位に分解することで品質を担保

2. **従来の開発手法との違い**
   - 人間の即座の修正に頼らない堅牢な設計が求められる
   - 「作りながら考える」から「考えてから作る」への転換
   - プロジェクト全体を俯瞰した一貫性のある実装

#### Claude Codeの計画支援機能

1. **Extended Thinking（拡張思考）**
   - 複雑なアーキテクチャ変更の計画立案
   - 複雑な問題のデバッグ戦略構築
   - 実装アプローチ間のトレードオフ評価
   - 使用方法: 「think」「think more」「think harder」などのフレーズで深い思考を促進

2. **CLAUDE.md による設計の一貫性確保**
   - プロジェクトメモリによる設計方針の永続化
   - アーキテクチャパターンの文書化
   - コーディング規約の統一
   - チームワークフローの標準化

3. **段階的アプローチ**
   - 複雑なタスクを小さな検証可能な単位に分解
   - 広範囲な質問から具体的な実装へと段階的に絞り込み
   - プロジェクト固有のパターンや規約の事前確認

#### 推奨されるワークフロー

1. **計画フェーズ**
   - Extended Thinkingを活用した設計検討
   - Git worktreeを使った複数タスクの並行計画
   - プロジェクトの用語集作成とドメイン言語の理解

2. **実装フェーズ**
   - 公開API、インターフェース、複雑なロジックの事前文書化
   - 例を含む一貫したドキュメントスタイル（JSDoc、docstringなど）
   - エッジケースとエラー条件を考慮したテスト設計

3. **検証フェーズ**
   - CI/CDパイプラインとの統合
   - 複数の検証スクリプトによる品質保証
   - フックを活用した自動化された品質チェック

#### 実装時の注意点

1. **設定とカスタマイズ**
   - 階層的設定ファイルによる柔軟な環境構築
   - ツール権限の詳細な制御
   - 企業レベルのセキュリティポリシー統合

2. **継続的な改善**
   - メモリファイルの定期的な見直しと更新
   - プロジェクト固有の規約の段階的な改善
   - チーム全体での設計方針の共有

計画・設計への投資は、後の開発フェーズでの生産性向上と品質保証に直結し、Claude Codeの自律的な能力を最大限に活用するための基盤となる。

## 記録を残す

Claude Codeにおける記録は、単なるドキュメント作成を超えて、自律的な開発を成功させるための重要な基盤となる。

### なぜ記録が重要なのか

1. **AIの認知特性への対応**
   - AIは成功したと思い込む傾向があるため、詳細なデバッグログが必要
   - 構造化されたログにより、AIが過去の試行錯誤を正確に把握
   - 失敗パターンの蓄積による同じ過ちの回避

2. **知見の蓄積と活用**
   - プロジェクト固有の知識を体系的に管理
   - 「生きた文書」として継続的に更新される記録
   - チーム全体での知識共有と技術的負債の削減

### Claude Codeでの記録管理

1. **CLAUDE.mdファイルの活用**
   - プロジェクト概要とアーキテクチャの記録
   - 開発コマンドと設定の文書化
   - コーディング規約とスタイルガイド

2. **.claudeディレクトリによる体系的管理**
   - `context.md`: プロジェクトの背景と制約
   - `project-knowledge.md`: 技術的な知見と学習内容
   - `project-improvements.md`: 改善履歴と変更理由
   - `common-patterns.md`: 定型的な実装パターン

3. **構造化されたログの実装**
   - AI時代に適した読みやすいログ形式
   - デバッグ情報の階層的な記録
   - エラーパターンとその解決策の文書化

### 効果的な記録の実践

1. **即座の記録習慣**
   - 重要な決定や発見をその場で記録
   - 技術選定の理由と背景の明文化
   - トラブルシューティングの過程と結果

2. **定期的な整理と更新**
   - 適切な頻度の情報整理
   - 古い情報の精査と更新
   - カスタムコマンドによるコンテキスト更新

3. **AIフレンドリーな記録形式**
   - 明確で具体的な文脈提供
   - 構造化されたマークダウン形式
   - エラーと成功パターンの明示的な区別

### 記録がもたらす効果

1. **開発効率の向上**
   - 過去の知見を新しい課題に即座に適用
   - 同じ問題での時間浪費を回避
   - AIの自律的な問題解決能力の向上

2. **品質保証の強化**
   - 一貫したコーディングスタイルの維持
   - ベストプラクティスの自動適用
   - エラーパターンの事前回避

3. **チーム開発の円滑化**
   - 知識の属人化を防止
   - 新規メンバーのオンボーディング効率化
   - プロジェクト全体の透明性向上

記録への投資は、Claude Codeの自律的な能力を最大限に引き出し、持続可能な開発プロセスを構築するための不可欠な要素である。

参考情報:
- 知見を蓄積する: https://zenn.dev/driller/articles/2a23ef94f1d603
- AIフレンドリーなログ: https://note.com/fladdict/n/n5046f72bdadd

## 堅牢なコードを書く

Claude Codeによる自律的な開発では、人間の即座の介入なしに動作する堅牢なコードが不可欠である。

### なぜ堅牢性が重要なのか

1. **自律的開発の前提条件**
   - AIが長時間にわたって安全にコードを生成するにはガードレールが必要
   - 人間の即座の修正に頼らない自己完結的な実装
   - エラーの早期発見と自動修正による開発サイクルの効率化

2. **品質保証の自動化**
   - 一貫したコード品質の維持
   - バグの事前防止による手戻りの削減
   - チーム全体での品質基準の統一

### 品質保証の仕組み

1. **自動化ツールの活用**
   - **Ruff**: リンターとフォーマッターの統合ツール
     - コードスタイルの統一（Black互換フォーマット）
     - 潜在的エラーやバグの検出
     - importの自動整理（isort互換）
   - **mypy**, **ty**: 静的型チェッカー
     - 型安全性の保証
     - 型アノテーションの検証
   - **pre-commit hooks**: コミット前の自動品質チェック

2. **プロアクティブなエラー検出**
   - ワークスペースの継続的な監視
   - 欠落したimportや型エラーの自動検出・修正
   - デバッグ時間の大幅削減
   - **Hooksの利点**: 
     - AIがコードを生成する瞬間に品質チェックを実行
     - 手動レビューの負担を軽減
     - プロジェクト固有の検証ルールをカスタマイズ可能

3. **Claude Code Hooks による自動化**
   - **AIコーディングワークフローへの統合**: ファイル編集時に即座に実行
   - **動的なコンテキスト認識**: Claude Codeのイベントに応じた柔軟な制御
   - **設定例（claude-code-settings.json）**:
     ```json
     {
       "hooks": {
         "PostToolUse": [
           {
             "matcher": "Write|Edit|MultiEdit",
             "hooks": [
               {
                 "type": "command",
                 "command": "ruff check --fix {file_path} && ruff format {file_path}"
               }
             ]
           }
         ]
       }
     }
     ```

4. **pre-commit hooks の設定例（.pre-commit-config.yaml）**
   ```yaml
   repos:
     # Ruff - 高速なPythonリンターとフォーマッター
     - repo: https://github.com/astral-sh/ruff-pre-commit
       rev: v0.11.13
       hooks:
         - id: ruff
           name: ruff linting
         - id: ruff-format
           name: ruff formatting check
           args: [--check]
     
     # mypy - 静的型チェック
     - repo: https://github.com/pre-commit/mirrors-mypy
       rev: v1.7.1
       hooks:
         - id: mypy
           args: [--ignore-missing-imports]
           additional_dependencies: [types-PyYAML, pydantic]
     
     # 基本的なファイルチェック
     - repo: https://github.com/pre-commit/pre-commit-hooks
       rev: v4.5.0
       hooks:
         - id: trailing-whitespace
         - id: end-of-file-fixer
         - id: check-yaml
         - id: check-toml
   ```

### テスト駆動開発（TDD）の実践

1. **AIはTDDが効果的**
   - ハルシネーションや範囲のずれを防ぐ効果的な方法
   - テストがターゲットとして機能し、実装の方向性を明確化
   - 反復的な改善プロセスの実現

2. **TDDワークフロー**
   - テストを先に書く（明示的にTDDを宣言）
   - テストが失敗することを確認
   - テストをコミット
   - テストを通すコードを実装
   - リファクタリング

3. **テストの効果**
   - 仕様の明文化と実装の検証
   - リグレッションの防止
   - 安全なリファクタリングの実現

### ガードレールの実装

1. **人間による監視と制御**
   - すべてのアクションに対する承認/拒否機能
   - Escapeキーで中断、ダブルEscapeで履歴を遡る
   - 自動承認モード（Shift+Tab）も可能だが、アクティブな協力が推奨

2. **Constitutional AIフレームワーク**
   - 有益で誠実、無害な相互作用を促進
   - 曖昧な要求には明確化を求める
   - 知識のギャップを認め、推測せずに不確実性を認める

3. **タスク履歴と元に戻す機能**
   - 自動的にタスクを保存
   - ファイルタイムラインで変更を追跡
   - Gitなしでも以前のバージョンに戻せる

### 実践的な開発プロセス

1. **構造化されたワークフロー**
   - **探索**: 関連ファイルを読む（コードは書かない）
   - **計画**: プランモードで詳細なステップバイステップの計画を作成
     - Claude Codeのプランモードを活用
     - 計画の承認を得てから実装開始
     - 計画の段階で設計の妥当性を検証
   - **テストと実装**: TDDで実装
   - **検証**: すべてのテストが通ることを確認
   - **コミット**: 品質基準を満たした後にコミット

2. **CLAUDE.mdによる品質基準の明文化**
   - プロジェクト固有のコンテキストを自動的に読み込む
   - テスト設定、ワークフロー、ベストプラクティスを文書化
   - チーム全体での品質基準の共有

3. **マルチエージェントレビューパターン**
   - 一つのClaudeがコードを書き、別のClaudeがレビューやテスト
   - 異なるコンテキストを持つことで品質向上
   - 人間のコードレビューを模倣した品質保証

### 品質チェックリスト

1. **コードの可読性**
   - 関数は読みやすく理解しやすいか？
   - 適切な命名規則に従っているか？
   - コメントは適切に配置されているか？

2. **設計の妥当性**
   - 循環的複雑度は適切か？
   - より適切なデータ構造やアルゴリズムはないか？
   - 不要なパラメータや型キャストはないか？

3. **エラーハンドリング**
   - 適切な例外処理が実装されているか？
   - エッジケースが考慮されているか？
   - エラーメッセージは明確で有用か？

### 安全性確保の実践

1. **データ保護とプライバシー**
   - すべてのコマンド実行にユーザー承認が必要
   - 機密データは慎重に扱われる
   - エンタープライズ環境に適したセキュリティ

2. **防御的コミット戦略**
   - Claudeは積極的にコミットしたがるため、慎重な指示が必要
   - 計画→実装→テスト→コミットの順序を守る
   - 品質基準を満たさないコードはコミットしない

3. **コスト意識のある開発**
   - 効率的なバッチ処理でツール呼び出しを最適化
   - 並列実行可能なタスクは同時に実行
   - 不要な繰り返しを避ける

堅牢なコードへの投資は、Claude Codeの自律的な能力を安全に活用し、持続可能で高品質な開発を実現するための必須要素である。