# Claude Codeの実践的なアプローチ

[みんなのPython勉強会#116](https://startpython.connpass.com/event/361667/)

driller[@patrqqushe](https://x.com/patraqushe) 2026-07-17

## Claude Codeの能力

### 簡単にできること

「テトリス作って」

- 単一機能のゲーム実装
- 明確な仕様の小規模プロジェクト
- 即座の実行と確認が可能

### 簡単にはできないこと

「航空機の予約システムを作って」

- 複雑なビジネスロジック
- 多数のコンポーネント統合
- 企業レベルの要件

### 違いは何か

複雑さとスコープの違い

- 単純なタスク vs 複雑なシステム
- 明確な要件 vs 曖昧な要求
- 即座の実行 vs 長期的な計画

### 実践的アプローチの必要性

複雑なタスクには体系的な手法が必要

- 計画・設計の立案
- 知識の記録と蓄積
- 堅牢なコード実装

## 背景

### 開発アプローチの変遷

シンプルなプロンプトから体系的なアプローチへ移行

### Vibe Codingの特徴

優秀な料理の助手として

- 直感的な対話型開発
- 自然言語での即座生成
- プロトタイプ向け
- 品質管理に限界

「さっぱりした和食のイメージで」といった抽象的指示

### Agentic Codingの特徴

ベテランシェフとして

- 自律的な目標達成
- 計画から実行まで自動化
- 企業レベル対応
- 監督者への役割変化

「顧客満足度を上げる新作メニュー開発」といった高レベル目標

### 従来アプローチの限界

- 複雑な要求に対応困難
- 品質担保が困難
- 管理性の欠如

### 生産性と品質の両立

- 開発速度向上
- 体系的な検証プロセス
- 堅牢なコード実装

### Claude Codeの位置づけ

- ターミナルベースエージェント
- 自律的なコードベース管理
- 7時間の連続自律開発実績
- Git統合による自動化

### 業界トレンドと実践的意味

- 2026年までの予測
- 人間指示→エージェント実行→人間審査
- ハイブリッドアプローチ
- 開発パラダイムの転換

## 3つのポイント

AI自律開発には計画と堅牢性が必要

- 計画・設計を立てる
- 記録を残す
- 堅牢なコードを書く

## 計画・設計を立てる

### 計画・設計の重要性

自律的な開発を成功させるための核心的要素

### なぜ重要なのか

- AIが長時間一貫した判断を下すには明確な指針が必要
- 7時間の連続自律開発実績（Anthropic）
- 複雑なタスクを検証可能な単位に分解

### 従来手法との違い

- 人間の即座修正に頼らない堅牢な設計
- 「作りながら考える」から「考えてから作る」へ
- プロジェクト全体の一貫性確保

### Claude Codeの計画支援機能

### Extended Thinking（拡張思考）

複雑な問題を深く考え抜く機能

- 複雑なアーキテクチャ変更の計画立案
- 複雑な問題のデバッグ戦略構築
- 実装アプローチ間のトレードオフ評価

### 使用方法

「think」「think more」「think harder」で深い思考を促進

### CLAUDE.mdによる設計の一貫性確保

プロジェクトメモリで設計方針を永続化

- アーキテクチャパターンの文書化
- コーディング規約の統一
- チームワークフローの標準化

### 段階的アプローチ

複雑な問題を体系的に分解

- 複雑なタスクを小さな単位に分解
- 広範囲から具体的実装へ段階的絞り込み
- プロジェクト固有パターンの事前確認

### 推奨ワークフロー

### 計画フェーズ

設計検討と準備の段階

- Extended Thinkingを活用した設計検討
- Git worktreeを使った複数タスクの並行計画
- プロジェクト用語集作成とドメイン言語理解
- 実装計画書による構造化された計画立案

### 実装計画の実例: PyQC開発

7段階の体系的実装プロセス

- Step 1-2: 基盤構築と設定管理システム
- Step 3-4: 核心機能実装とCLI開発
- Step 5-7: 統合・品質保証・ドキュメント完成
- 段階的な完了条件で進捗を管理

### 完了条件の明確化

具体的な成果物とメトリクス

- 機能要件: 基本CLIコマンド動作
- 品質要件: テストカバレッジ >75%
- 統合要件: Claude Code hooks動作
- 文書要件: README.md完成

### 実装フェーズ

事前文書化と設計重視

- 公開API、インターフェース、複雑ロジックの文書化
- 一貫したドキュメントスタイル（JSDoc、docstring）
- エッジケースとエラー条件を考慮したテスト設計
- 実装計画書による進捗管理と完了条件の確認

### 検証フェーズ

品質保証と自動化

- CI/CDパイプラインとの統合
- 複数の検証スクリプトによる品質保証
- フックを活用した自動化品質チェック

### 実装時の注意点

### 設定とカスタマイズ

環境構築の最適化

- 階層的設定ファイルによる柔軟な環境構築
- ツール権限の詳細な制御
- 企業レベルのセキュリティポリシー統合

### 継続的な改善

設計の進化と共有

- メモリファイルの定期的な見直しと更新
- プロジェクト固有規約の段階的改善
- チーム全体での設計方針共有

### まとめ

計画・設計への投資は後の開発フェーズでの生産性向上と品質保証に直結し、Claude Codeの自律的な能力を最大限に活用するための基盤となる。

## 記録を残す

### 記録を残すことの重要性

自律的な開発を成功させる重要な基盤

### なぜ記録が重要なのか

### AIの認知特性への対応

AIは成功したと思い込む傾向がある

- 詳細なデバッグログが必要
- 構造化されたログでAIが過去を正確に把握
- 失敗パターンの蓄積で同じ過ちを回避

### 知見の蓄積と活用

プロジェクト固有の知識を体系的に管理

- 「生きた文書」として継続的に更新
- チーム全体での知識共有
- 技術的負債の削減

### Claude Codeでの記録管理

### CLAUDE.mdファイルの活用

プロジェクトの核となる記録

- プロジェクト概要とアーキテクチャ
- 開発コマンドと設定の文書化
- コーディング規約とスタイルガイド

### .claudeディレクトリによる体系的管理

知識を構造化して管理

- `context.md`: 背景と制約
- `project-knowledge.md`: 技術的知見
- `project-improvements.md`: 改善履歴
- `common-patterns.md`: 定型パターン
- `plans/`: 実装計画の体系的管理

### 実装計画管理

構造化された計画立案と進捗追跡

- 計画の採番システム（PLAN-YYYY-MM-DD-XXX）
- 進捗状況の追跡（planning/in_progress/completed）
- 完了条件の明確化と検証
- 実装履歴の保存とパターン学習

### 構造化されたログの実装

AI時代に適したログ形式

- 読みやすいログ形式
- デバッグ情報の階層的記録
- エラーパターンと解決策の文書化

### 効果的な記録の実践

### 即座の記録習慣

発見をその場で記録

- 重要な決定や発見を即座に記録
- 技術選定の理由と背景の明文化
- トラブルシューティングの過程と結果

### 実装ログの実例: PyQC開発

構造化された進捗記録

- 実装開始 - Step 1開始（基盤構築）
- Step 1完了 - プロジェクト基盤構築完了
- Step 2完了 - 設定管理システム（カバレッジ97%）
- 全完了条件達成 - MVP実装完了

### 完了時の振り返り実践

学習成果の体系的記録

- うまくいったこと: TDD実践、段階的実装
- 改善点: テストカバレッジ目標未達
- 学んだこと: AI時代の品質保証手法
- 今後の活用: プレゼンテーション素材として

### 定期的な整理と更新

記録の鮮度を保つ

- 適切な頻度の情報整理
- 古い情報の精査と更新
- カスタムコマンドによるコンテキスト更新

### AIフレンドリーな記録形式

AIが理解しやすい形式で記録

- 明確で具体的な文脈提供
- 構造化されたマークダウン形式
- エラーと成功パターンの明示的区別

### 記録がもたらす効果

### 開発効率の向上

過去の知見を活用

- 新しい課題に即座に適用
- 同じ問題での時間浪費を回避
- AIの自律的な問題解決能力向上

### 品質保証の強化

一貫性のある高品質な開発

- コーディングスタイルの維持
- ベストプラクティスの自動適用
- エラーパターンの事前回避

### チーム開発の円滑化

知識の共有と透明性

- 知識の属人化を防止
- 新規メンバーのオンボーディング効率化
- プロジェクト全体の透明性向上

### まとめ

記録への投資はClaude Codeの自律的な能力を最大限に引き出し、持続可能な開発プロセスを構築するための不可欠な要素である。

## 堅牢なコードを書く

### 堅牢性の重要性

人間の即座の介入なしに動作する堅牢なコードが不可欠

### コードの堅牢性とは何か

ガードレールなし

:::::{grid}
:gutter: 2

::::{grid-item}
- 安全機能の欠如
- 予期しない障害に対応できない  
- 開発者の即座の介入が必要
::::

::::{grid-item}
:::{figure} _static/images/ev01.jpeg
:alt: ガードレールなしの自動運転EV
:width: 80%
:::
::::

:::::

### 堅牢なコードの必要性

ガードレールあり

:::::{grid}

::::{grid-item}
- 適切な安全機能
- 自律的な問題回避
- 継続的な安全運転
::::

::::{grid-item}
:::{figure} _static/images/ev02.jpeg
:alt: ガードレールありの自動運転EV
:width: 80%
:::
::::

:::::

### なぜ堅牢性が重要なのか

### 自律的開発の前提条件

AIが長時間安全にコードを生成するにはガードレールが必要

- 人間の即座修正に頼らない自己完結的な実装
- エラーの早期発見と自動修正による開発効率化
- 堅牢性なくして自律開発は成立しない

### 品質保証の自動化

一貫した品質維持と効率化

- 一貫したコード品質の維持
- バグの事前防止による手戻り削減
- チーム全体での品質基準の統一

### 品質保証の仕組み

### 自動化ツールの活用

高品質なコードを継続的に生成

- **Ruff**: リンター・フォーマッターの統合
- **mypy**, **ty**: 静的型チェッカー
- **pre-commit hooks**: コミット前の品質チェック

### プロアクティブなエラー検出

問題を事前に発見し修正

- ワークスペースの継続的な監視
- 欠落したimportや型エラーの自動検出・修正
- デバッグ時間の大幅削減

### Claude Code Hooksによる自動化

AIコーディングワークフローに統合

- ファイル編集時に即座に実行
- 動的なコンテキスト認識
- プロジェクト固有の検証ルール

### テスト駆動開発（TDD）の実践

### AIはTDDが効果的

ハルシネーションや範囲のずれを防ぐ

- テストがターゲットとして機能
- 実装の方向性を明確化
- 反復的な改善プロセス

### TDD実践の実例: PyQC開発

具体的な成果と品質指標

- 総テスト数: 140テスト
- テストカバレッジ: 75%達成
- 単体テスト: 91テスト（core機能）
- 統合テスト: 27テスト（CLI）
- E2Eテスト: 9テスト（hooks）

### AI時代の品質保証

高頻度コミットに対応した品質チェック

- pre-commit hooks: コミット前の自動チェック
- Claude Code hooks: リアルタイム品質チェック
- 並列実行: 複数品質ツールの統合
- 即座のフィードバック: 開発効率の向上

### TDDワークフロー

品質の高いコードを体系的に構築

- テストを先に書く
- テストが失敗することを確認
- テストを通すコードを実装

### テストの効果

安全で信頼性の高い開発

- 仕様の明文化と実装の検証
- リグレッションの防止
- 安全なリファクタリング

### ガードレールの実装

### 人間による監視と制御

AIの暴走を防ぐ安全装置

- すべてのアクションに対する承認/拒否機能
- Escapeキーで中断、ダブルEscapeで履歴を遡る
- 自動承認モード（Shift+Tab）も可能

### Constitutional AIフレームワーク

安全で有用なAIの実現

- 有益で誠実、無害な相互作用を促進
- 曖昧な要求には明確化を求める
- 知識のギャップを認め、推測せず不確実性を認める

### タスク履歴と元に戻す機能

安全な開発環境の提供

- 自動的にタスクを保存
- ファイルタイムラインで変更を追跡
- Gitなしでも以前のバージョンに戻せる

### 実践的な開発プロセス

### 構造化されたワークフロー

段階的で安全な開発手順

- **探索**: 関連ファイルを読む（コードは書かない）
- **計画**: プランモードで詳細なステップ作成
- **テストと実装**: TDDで実装
- **検証**: すべてのテストが通ることを確認

### CLAUDE.mdによる品質基準の明文化

プロジェクト固有の品質基準

- プロジェクト固有のコンテキストを自動読み込み
- テスト設定、ワークフロー、ベストプラクティスを文書化
- チーム全体での品質基準の共有

### 他のAIを活用したレビュー

複数AIによる品質向上アプローチ

### Gemini CLIでのレビュー実践

Claude Codeで生成したコードを別のAIでレビュー

- Claude Codeでコード実装
- Gemini CLIで客観的なレビュー実行
- 異なるAIモデルの視点による品質向上

### 複数AIツールの特徴活用

各AIの強みを活かした役割分担

- **Claude**: コード生成とアーキテクチャ設計
- **Gemini**: 別視点でのレビューと改善提案
- **GitHub Copilot**: 補完的なコード提案

### 実践的なワークフロー

段階的な品質向上プロセス

1. **実装**: Claude Codeでコード生成
2. **レビュー**: Gemini CLIで客観的評価
3. **改善**: レビュー結果をもとに修正
4. **検証**: 最終的な品質確認

### 利点と注意点

### 利点

多角的な品質向上

- 異なる視点による包括的なレビュー
- バイアス軽減と客観性向上
- 品質基準の多様化

### 注意点

効率性と一貫性の確保

- 一貫性のある品質基準の維持
- 効率的なワークフローの構築
- ツール間の連携コスト考慮

### コードレビューチェックリスト

### レビュー時の可読性チェック

コードレビューで確認すべき可読性の観点

- 関数は読みやすく理解しやすいか？
- 適切な命名規則に従っているか？
- コメントは適切に配置されているか？

### 設計レビューのポイント

レビュー時に確認すべき設計の観点

- 循環的複雑度は適切か？
- より適切なデータ構造やアルゴリズムはないか？
- 不要なパラメータや型キャストはないか？

### エラーハンドリングのレビュー

レビュー時に確認すべきエラー処理の観点

- 適切な例外処理が実装されているか？
- エッジケースが考慮されているか？
- エラーメッセージは明確で有用か？

### 安全性確保の実践

### データ保護とプライバシー

セキュアな開発環境

- すべてのコマンド実行にユーザー承認が必要
- 機密データは慎重に扱われる
- エンタープライズ環境に適したセキュリティ

### 防御的コミット戦略

品質の高いコードのみをコミット

- 計画→実装→テスト→コミットの順序を厳守
- 品質基準を満たさないコードはコミットしない
- 慎重なコミット戦略で品質を保証

### コスト意識のある開発

効率的な開発プロセス

- 効率的なバッチ処理でツール呼び出しを最適化
- 並列実行可能なタスクは同時に実行
- 不要な繰り返しを避ける

### まとめ

堅牢なコードへの投資はClaude Codeの自律的な能力を安全に活用し、持続可能で高品質な開発を実現するための必須要素である。

## PyQC実装例: 統合的な学習成果

### 開発概要

Python品質チェックツールのMVP実装

- 実装手法: 自律的なAI開発
- 実装規模: 140テスト、75%カバレッジ
- 統合ツール: ruff + mypy/ty
- 品質重視: TDD実践による堅牢性

### 3つのポイントの実践

実際の開発プロセスでの適用

#### 1. 計画・設計を立てる

- 7段階実装プロセスの体系化
- 段階的な完了条件設定
- Git worktreeによる並行開発

#### 2. 記録を残す

- リアルタイム進捗ログ
- 完了時の振り返り記録
- 技術的知見の体系化

#### 3. 堅牢なコードを書く

- TDD実践（140テスト）
- Claude Code hooks統合
- 自動品質チェック体制

### 学習成果

AI時代の開発手法への知見

- **品質保証の自動化**: 高頻度コミットに対応した品質チェック
- **統合設計パターン**: 複数ツール（ruff + mypy/ty）の統合手法
- **自律開発手法**: 計画と記録による一貫した開発プロセス
- **実用的ワークフロー**: Claude Code hooksによるリアルタイム品質管理

### 実装手法の価値

TDD実践による堅牢性の確保

- **テスト駆動開発**: 140テストによる品質担保
- **段階的実装**: 7つのステップで体系的な開発
- **完了条件管理**: 明確な成果物で進捗を可視化
- **自動化統合**: hooks機能による開発効率向上